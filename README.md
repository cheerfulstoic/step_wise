# StepWise

`StepWise` is an Elixir library to wrap sequences of code which might fail.

 * It encourages standards by requiring the use of `{:ok, _}` and `{:error, _}` tuples (no `:ok`, or `{:error, _, _}`)
 * It rescues / catches anything which bubbles up so that you don't have to.  All exceptions/throws can be returned as `{:error, _}` tuples with` StepWise.resolve` or raised as an exception with `StepWise.resolve!`
 * It can perform operations on enumerables, requiring that each iteration succeeds (via `StepWise.map_step`)
 * It sends `telemetry` events which you can subscribe to do whatever you like across all processes using `StepWise` (i.e. logging, metrics, tracing, etc...)

# Code Sample

```elixir
defmodule MyApp.NotifyCommenters do
  def run(post) do
    post
    |> StepWise.step(&MyApp.Posts.get_comments/1)
    # |> StepWise.map_step(&get_commenter/1)
    |> StepWise.map_step(fn comment ->
      # get_commenter/1 doesn't return `{:ok, _}`, so we need
      # to do that here

      {:ok, MyApp.Posts.get_commenter(comment)}
    end)
    |> StepWise.step(&notify_users/1)
    |> StepWise.resolve()
  end

  def notify_users(user) do
    # ...
  end
end
```


`StepWise` will `rescue` from exceptions and `catch` any uncaught `throw`s so that they can be converted into stardard `{:error, _}` tuples (or consistently raised with `resolve!/2`).  `exit`s, however, are *not* caught on purpose because, as [this Elixir guide](https://elixir-lang.org/getting-started/try-catch-and-rescue.html#exits) says: "exit signals are an important part of the fault tolerant system provided by the Erlang VM..."

# Telemetry

`StepWise` implements telemetry events so that actions such as logging, metrics, and tracing can be separated as a different concern to your code.  There are three telemetry events:

## `[:step_wise, :step, :start]`

Executed when a step starts with the following metadata:

 * `id`: A unique ID generated by `:erlang.unique_integer()`
 * `step_func`: The function object given to the `step` / `step_map` function
 * `module`: The module where the `step_func` is defined (for convenience)
 * `func_name`: The name of the `step_func` (for convenience)
 * `system_time`: The system time when the step was started

## `[:step_wise, :step, :stop]`

Executed when a step stop with all of the same metadata as the `start` event, but also a `result` key which is the value that was returned from the step function

## `[:step_wise, :resolve]`

Executed when `resolve/2` and `resolve!/2` are called.  Given the following metadata:

 * `name`: The name given to the resolve function.
 * `system_time`: The system time when the step was started
 * `result`: The result given to the resolve function
 * `success`: A boolean describing if the result was a success (for convenience, based on `result`)

## Installation

If [available in Hex](https://hex.pm/docs/publish), the package can be installed
by adding `step_wise` to your list of dependencies in `mix.exs`:

```elixir
def deps do
  [
    {:step_wise, "~> 0.1.0"}
  ]
end
```

Documentation can be generated with [ExDoc](https://github.com/elixir-lang/ex_doc)
and published on [HexDocs](https://hexdocs.pm). Once published, the docs can
be found at <https://hexdocs.pm/step_wise>.

# TODO TODO TODO

 * Ability to pass in options to signify telemetry metadata

