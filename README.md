# StepWise

`StepWise` is a light wrapper for the parts of your code which need to be debuggable in production.  That means that it:

 * ...encourages the breaking down of such code into step
 * ...requires that each step returns a success of failure state (via standard `{:ok, _}` and `{:error, _}` tuples)
 * ...provides telemetry events to separate/centralize code for concerns such as logging, metrics, and tracing.

Let's look at some code and then discuss some highlights...

```elixir
defmodule MyApp.NotifyCommenters do
  def run(post) do
    post
    |> StepWise.step(&MyApp.Posts.get_comments/1)
    |> StepWise.map_step(fn comment ->
      # get_commenter/1 doesn't return `{:ok, _}`, so we need
      # to do that here

      {:ok, MyApp.Posts.get_commenter(comment)}
    end)
    |> StepWise.step(&notify_users/1)
    |> StepWise.resolve()
  end

  def notify_users(user) do
    # ...
  end
end
```

You might notice that the `step/1` and `map_step/1` functions take function values.  These can be anonymous (like used above in `map_step`), though errors will be clearer when using function values coming from named functions.

The `step` and `map_step` functions `rescue` / `catch` anything which bubbles up so that you don't have to.  All exceptions/throws can be returned as `{:error, _}` tuples so that they can be handled.  `exit`s, however, are *not* caught on purpose because, as [this Elixir guide](https://elixir-lang.org/getting-started/try-catch-and-rescue.html#exits) says: "exit signals are an important part of the fault tolerant system provided by the Erlang VM..."

# State-Based Usage

Above is a primary use-case of chaining together functions in a pipe-like way (starting with one value and transforming or replacing it as the chain progresses).  In some cases, however, you may want to use a more `GenServer`-like style where you have a state object that is modified along the way:

```elixir
def EmailPost do
  def run(user_id, post_id) do
    %{user_id: user_id, post_id: post_id}
    |> StepWise.step(&MyApp.Posts.get_comments/1)
    |> StepWise.step(&fetch_user_data/1)
    |> StepWise.step(&fetch_post_data/1)
    |> StepWise.step(&finalize/1)
    |> StepWise.resolve(:basic_success)
  end

  def fetch_user_data(%{user_id: id} = state) do
    {:ok, Map.put(state, :user, MyApp.Users.get(id))}
  end

  def fetch_post_data(%{post_id: id} = state) do
    {:ok, Map.put(state, :post, MyApp.Posts.get(id))}
  end

  def finalize(%{user: user, post: post}) do
    # ...
  end
end
```

# Telemetry

As my colleague @linduxed put it: "Logging definitely feels like one of those areas where it very quickly jumps from 'these sprinkled out log calls are giving us a lot of value' to 'we now have a mess in both code and log output'".

`StepWise` implements telemetry events so that actions such as logging, metrics, and tracing can be separated as a different concern to your code.  There are three telemetry events:

## `[:step_wise, :step, :start]`

Executed when a step starts with the following metadata:

 * `id`: A unique ID generated by `:erlang.unique_integer()`
 * `step_func`: The function object given to the `step` / `step_map` function
 * `module`: The module where the `step_func` is defined (for convenience)
 * `func_name`: The name of the `step_func` (for convenience)
 * `system_time`: The system time when the step was started

## `[:step_wise, :step, :stop]`

Executed when a step stop with all of the same metadata as the `start` event, but also a `result` key which is the value that was returned from the step function

## `[:step_wise, :resolve]`

Executed when `resolve/2` and `resolve!/2` are called.  Given the following metadata:

 * `name`: The name given to the resolve function.
 * `system_time`: The system time when the step was started
 * `result`: The result given to the resolve function
 * `success`: A boolean describing if the result was a success (for convenience, based on `result`)

## Installation

If [available in Hex](https://hex.pm/docs/publish), the package can be installed
by adding `step_wise` to your list of dependencies in `mix.exs`:

```elixir
def deps do
  [
    {:step_wise, "~> 0.1.0"}
  ]
end
```

Documentation can be generated with [ExDoc](https://github.com/elixir-lang/ex_doc)
and published on [HexDocs](https://hexdocs.pm). Once published, the docs can
be found at <https://hexdocs.pm/step_wise>.

# TODO TODO TODO

 * Ability to pass in options to signify telemetry metadata

